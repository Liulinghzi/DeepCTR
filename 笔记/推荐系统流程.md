<!--
 * @Author: your name
 * @Date: 2020-04-15 14:16:52
 * @LastEditTime: 2020-04-15 16:08:25
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /DeepCTR/笔记/推荐系统流程.md
 -->

工业推荐系统架构https://zhuanlan.zhihu.com/p/58160982

FM FFM一般是用来做排序的，本身也是在deepctr包里面
用来做召回和排序有什么区别

1. 召回：
    1. 理论差别
        召回时有大量样本 =》 大量和用户基本无关的样本 =》 不好学习
        排序时有少量样本 =》 基本都有关，有些更有关 =》 模型容易学到区别
    1. 只使用用户少量的特征，快速从大量的物品中选择少部分用户感兴趣的物品。
    2. 将给用户推荐的物品降到千以下规模
    3. 通常多路召回，常用路数如下（相当于每一路召回用了一个特征）
        1. 兴趣标签
        2. 热门
        3. 协同过滤
        4. 相同地域
            缺点：
            1. 不同路数之间的召回分数，不能比较，必能说根据兴趣标签召回的高得分样本 比 根据热门标签召回的低得分样本更重要（但其实不重要，因为经过排序之后，就可比了）
            2. 但是带来了一个附带问题，每一路召回的数量比例应该怎么设置，兴趣标签的物品是否应该比热门的物品少？？不好设置。一般都是拍脑门想的，但是很少找到最好的
            3. 工业上ranking和recall是两拨人，如果多加了一路召回，但是排序不知道，没有加对应的特征，那多的召回就没用
    4. 统一召回：FM，只用一路召回，用了多个特征
    5. 训练好的FM召回怎么使用
        1. 特征分类(所有特征的embedding统一为dim维)
            1. 和用户有关的n各特征
            1. 和物品有关的m个特征
            1. 上下文有关的p个特征(时间地点)
        2. 只考虑user-item
            1. n个特征相加为一个用户特征
            2. m个特征相加为一个item特征（为什么可以相加：向FM公式化简一样推导）
            这应该也是deepFM dnn和FM统一一套embedding的原因，要统一使用
        3. 考虑context
            1. context和user交叉
                score1 = <context, user>
            2. context和item交叉
                score2 = <context + user, item>
                组合了<context, item>的同时组合了<users, item>
            3. score = score1 + score2
                score1和物品无关，所以不影响用户对众多物品的排序
                TODO: 不影响顺序的得分有什么作用？？

2. 排序：使用大量特征进行复杂模型计算，精准推荐用户喜欢的物品
    1. 粗排：召回返回的物品还是太多了，类似第二次召回
    2. 精排
    3. 重拍